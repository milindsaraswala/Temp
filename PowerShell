# InfoPath Rules Extractor
param (
    [string]$SourcePath = "C:\InfoPathExported",
    [string]$OutputCsv = "C:\InfoPathRulesExport.csv"
)

$rulesList = @()

# Get all .xsl files (views)
Get-ChildItem -Path $SourcePath -Filter *.xsl -Recurse | ForEach-Object {
    $file = $_.FullName
    Write-Host "Processing $file"
    
    try {
        [xml]$xml = Get-Content -Path $file
    }
    catch {
        Write-Warning "Could not parse XML from $file"
        return
    }

    # Look for xd:Rule nodes in XSL
    $namespaceManager = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $namespaceManager.AddNamespace("xsl", "http://www.w3.org/1999/XSL/Transform")
    $namespaceManager.AddNamespace("xd", "http://schemas.microsoft.com/office/infopath/2003/xslt")

    $rules = $xml.SelectNodes("//xd:rule", $namespaceManager)

    foreach ($rule in $rules) {
        $ruleName = $rule.GetAttribute("name")
        $control = $rule.ParentNode.GetAttribute("match") # XPath where rule applies
        $conditions = $rule.SelectNodes(".//xd:condition", $namespaceManager) | ForEach-Object { $_.OuterXml -join ";" }
        $actions = $rule.SelectNodes(".//xd:action", $namespaceManager) | ForEach-Object { $_.OuterXml -join ";" }

        $rulesList += [PSCustomObject]@{
            ViewFile   = $_.Name
            RuleName   = $ruleName
            Control    = $control
            Conditions = $conditions
            Actions    = $actions
        }
    }
}

if ($rulesList.Count -gt 0) {
    $rulesList | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
    Write-Host "âœ… Extraction complete. Rules exported to $OutputCsv" -ForegroundColor Green
} else {
    Write-Warning "No rules found in the provided path."
}